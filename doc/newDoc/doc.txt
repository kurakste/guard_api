У приложения три компонента. Сервер(srv) мобильное приложение (app) и 
контрольная панель операторов. Взаимодействие происходит по протоколу 
webSoсket (библиотека socket.io). 

Формат сообщения который передается по сокетам: 
{
  payload: Object,
}

======================== контрольная панель ====================================
При запуске контрольная панель создает соединение по сокету с сервером.

Контрольная панель проходит аутентификацию на сервере. ( см. ниже)
Параметром подключения к сокету является token, это строка - зашифрованный объект 
пользователя. Время жизни сокета - 96 часов. После этого пользователь должен 
получить токен. Если приложение получает в событии srvError код ошибки от 0-10 - 
это ошибки связанные с авторизацией. При возникновении таких ошибок приложение 
делает редирект на страницу регистрации. После чего пользователь должен получить 
новый токен.

Для не авторизированных пользователей сервер готов принять два сообщения: 

Общение контрольная панель-сервер:

Исходящие сообщения от контрольной панели к серверу:
  cpRegisterNewCpUser:
    Запрос на регистрацию нового пользователя.
    payload: объект пользователя включая пароль.
    комментарий: получит либо ответ (см. srvNewUserWasCreated) либо ошибку в 
    обработчик ошибок
  
  cpSignIn:
    Запрос на авторизацию.
    payload: объект с двумя обязательными полями email, password 
    комментарий: получит либо ответ (см. srvLoginOk)либо ошибку в 
    обработчик ошибок
  
  cpPickedUpAlarm
    Оператор взял тревогу в обработку:
    payload:  объект тревога 

  cpAlarmGbrSent: 
    Оператор отправил группу
    payload:объект тревога 

  cpAlarmClosed:
    Оператор закрыл тревогу
    payload: объект тревога

  cpAlarmDecline
     Оператор отклонил тревогу
     payload: объект тревоги 
  
  cpAppUserApprove
    Оператор подтвердил пользователя приложения
    payload: user
  
  cpAppUserDecline    
  Оператор отклонил пользователя приложения
    payload: {
      user, comment:string
    }
  
  cpCpUserApprove
    Оператор подтвердил пользователя контрольной панели
    payload: user
  
  cpCpUserDecline
    Оператор отклонил пользователя контрольной панели
    payload: {
      user, comment:string
    }

Входящие сообщения на контрольную панель от сервера:
  srvErrMessage
    Ошибки от сервера.
    payload: { message, code }
    от 0-10 ошибки авторизации, 
    1 - все ошибки при SignUp кроме проверки email на уникальность
    7 - пользователь с таким email существует(при регистрации). 
    8 - пользователь не подтвержден админом.
    3 - auth token absent ....
    4 - auth token incorrect or expired.
    6 - прочие ошибки при SignIn
    11 - ошибки подтверждения/отклонения пользователя

  srvNewUserWasCreated:
    ответ на запрос создания нового пользователя
    payload: {
      result: true
    }
    Если нет ошибки можно сказать пользователю что учетная запись создана,
    но должна быть подтверждена администратором. Перенаправить на страницу 
    авторизации.

  srvLoginOk
    ответ на успешный запрос авторизации
    payload: {
      token:'jfdsqlksjdflskdf',
      user: объект пользователя. 
    }
    нужно сохранить токен и передавать со всеми остальными запросами
    
  srvUpdateUserList: 
    На сервере обновился лист подключенных пользователей контрольной панели. 
    Будет отправляться при подключении нового пользователя к панели, что бы
    получить полный список текущих пользователей.
    payload: [ id1, id2, id3 ...]

  srvNewUserConnected:
    на сервер подключился новый пользователь контрольной панели
    payload: id
  
  srvNewUserDisconnected:
    от сервера отключился пользователь контрольной панели
    payload: id
  
  srvUpdateAllCpUserList:
    На сервере обновился полный список пользователей контрольной панели. 
    Возможно добавлен/удален пользователь. Возможно изменен. 
    payload: [user1, user2, ...]

  srvUpdateOneCpUser:
    Изменилось состояние пользователя. 
    payload: user
  
  srvUpdateAllAppUserList:
    На сервере обновился полный список пользователей приложения. 
    Возможно добавлен/удален пользователь. Возможно изменен. 
    payload: [user1, user2, ...]
  
  srvUpdateOneAppUser:
    Изменилось состояние пользователя. 
    payload: user

  srvUpdateAlarmListAll:
    На сервере обновился общий лист тревог.
    Payload: массив объектов тревог
    комментарий: как правило будет случаться в момент подключения к серверу. Нужно 
    обновить список тревог в интерфейсе. 
  
  srvCreateNewAlarm: 
    создана новая тревога от пользователя
    payload: объект тревога
    комментарий: пользователь создал новую тревогу
 
  srvDeleteAlarm:
    Тревога закрыта оператором
    payload: объект тревога
    комментарий: будет возникать когда оператор отклонит или завершит тревогу 
  
  srvUpdateAlarm:
    Тревога изменена оператором
    payload: объект тревога
    комментарий: будет возникать когда тревога обновлена сервером 


===================== Приложение для пользователя ===========================
  Установка и регистрация: 
  1) Приложение нельзя использовать без регистрации. Пользователь должен пройти 
  регистрацию и отдать на загрузку копии документов. Согласиться с договором.

    API POST: _api_/user-new-ap
      Content-type: multipart/form-data
          params: 
            firstName: string,
            lastName: string,
            email: string,
            tel: string,
            password: string,
            img: file,
            pasImg1: file,
            pasImg2: file,
          returns: json:
            firstName: string,
            lastName: string,
            email:string,
            tel:string,
            img: file,
            pasImg1: file,
            pasImg2: file.

      Пример ответа при успешной регистрации:
        {
          "success": true,
          "message": "",
          "errorCode": 0,
          "payload": {
            "id": 29,
            "firstName": "Diman",
            "lastName": "Petrov",
            "email": "1petrov@gmail.com",
            "tel": "+79176450029",
            "role": 32,
            "active": false,
            "notes": "",
            "updatedAt": "2019-09-29T16:27:30.778Z",
            "createdAt": "2019-09-29T16:27:30.778Z",
            "img": null,
            "pasImg1": null,
            "pasImg2": null
          }
        }

  2) После регистрации он переадресуется на авторизацию.
    API POST: _api_/sign-in
    Content-type: json
      json: {
        email: string,
        password: string,
      }
    Ответ: 
      {
        "success": true,
          "message": "",
          "errorCode": 0,
          "payload": {
            user: User,
            token: 'string'
          }
      }

  3) Восстановление пароля - на почту отправляется сообщение с кодом для востановления пароля.
    API POST: _server_/restore_password
    запрос отдает json формата:
      {
        success: boolean,
        errorCode: number, 
        message: string,
        payload: { 
          code: string, 
          token: string // токен нужно вернуть назад, 
          },
      }

    Время жизни токена - 30 минут.
    Такой же код отправляется пользователю по эл. почте.
    Нужно дождаться ввода пользователя. 
    Если код совпал - ввод нового пароля.
    Сохраняем новый пароль: 
    Нет - стоим на месте, ждем верный код. 
    Нужна кнопка отправить новый код. 


    API POST: _server_/update_password
      body json:  {
        token: string,
        password, string,
      }
    
    Ответ json: 
      {
        success: boolean,
        errorCode: number, 
        message: string,
        payload: { null },
      }
  
    errorCode: 301 - истекло время жизни кода. Нужно вывести сообщение и 
    сделать запрос на новый код и токен для восстановления пароля. 
    Если смена пароля удачно нужно сказать пользователю и перевести на экран 
    авторизации.
  
  
  4) Авторизация пользователя.
    API POST: _server_/sign_in
      body json:  {
          login: string,
          password, string,
        }
      response:
      {
        success: boolean,
        errorCode: number, 
        message: string,
        payload: { user: User, token: string },
      }
    После успешной авторизации приложение получает токен, который нужно 
    сохранить и использовать для дальнейших запросов. Также получает объект 
    пользователя. Его нужно сохранить. В частности он будет использован на странице
    учетная запись и при редактировании учетной записи. 
    errorCode: 308 - пользователь есть, но он еще не активен. Ждет подтверждения от 
    администратора.

    У пользователя есть три роли(статуса). 
      1) Кандидат, в поле роль(role) будет 31. Значит пользователь еще не проверен
      операторами. Ему доступны все экраны но он не может нажать кнопку вызова. 
      Она как-то говорит о том, что его еще проверяют нужно подождать.
      2) В поле роль(role) стоит код 33 - пользователь заблокирован администрацией.
      Нужно обратится в техподдержку. 
      3) В поле роль(role) стоит код 35. Полноценный пользователь которому доступен 
      весь функционал. 
      Других кодов в поле роль быть не должно. Ели так случится - ошибка. 
      // TODO: продумать механизм логирования таких ошибок.
    
    5) Штатная работа приложения. 
      При подгрузки главного экрана приложение считывает координаты пользователя. 
      Если доступа к координатам нет - то нужно подсветить значок gps красным. 
      Кнопка вызова группы нажиматься не должна. 
      устанавливает соединение с сервером по сокету:
        _url_socket_api_/app-clients?token=auth_token 

      если соединение с сокетом установленно - показывает что сервер доступен. 
      Если нет, значок соединения - красный. 
      Соединение установлено, координаты получены - карта отображает отображает 
      текущее положение пользователя. 

      При нажатии на кнопку длительностью пять секунд (кнопка при этом постепенно
      заливается желтым как на макете). 
      Приложение отправляет на сервер по сокету сообщение:

        После подключения к сокету приложение должно ожидать события:
        // это событие может поступать и в дальнейшем, например после биллинга 
        srvSendAppState: 
        payload: 
          {
            paid: boolean, // оплачен ли текущий период, другими словами внесена ли абон. плата
            alarmId: number or null, // если не нул - значить есть открытая тревога нужно перейти в состояние тревоги.
            tid: number or null,  // если не нул - значит писали трек, нужно продолжить. 
            alarmHistory: [
              alarm1, alarm2, ....
            ],
            autoSubscription: boolean, // включено ли автоматическое продление подписки?

          } 
        
        событие: appStartNewTrack
        сообщение
        {
          token: string,
          payload: [lat, lon]
        }

        Приложение слушает событие: srvAcceptNewTrack
        Событие подтверждает что сервер начал отслеживать перемещения пользователя. 
        payload: { tid: number } - // айди созданного трека, его нужно хранить пока трек активен.
        Теперь сервер отслеживает перемещения пользователя. Приложение раз в 30 минут
        отправляет на сервер сообщения: 

        событие: appTrackAddPoint
        тело сообщения:
        {
          token: string,
          payload: { tid: number, loc: [lat, lon] } // tid - айди текущего трека.
        }

      При повторном длительном нажатии не кнопку(5 сек) кнопка заливается красным 
      состояние тревоги. На сервер отправляется событие: 
        appNewAlarm: 
        тело сообщения: 
          {
            token: string,
            payload: { loc: [ lat: number, lon:number ]}, 
          }

      Приложение слушает событие: srvAcceptNewAlarm
      payload: { alarmId: number }
      Нужно сохранить alarmId и хранить его пока тревога активна.

      В состоянии тревоги приложение раз в 30 сек отправляет свои координаты на сервер
      по событию: 
        appAlarmAddPoint:
        тело сообщения: 
        {
          token: string,
          payload: { alarmId: number, loc: [ lat: number, lon:number ]},
        }

      
      Отмена тревоги вызывается в пункте меню "ОТМЕНИТЬ ТРЕВОГУ"
      отмена тревоги происходит эмиссией события в сокет:
        appCancelAlarm: 
        тело сообщения: 
        {
          token: string,
          payload: { alarmId: number },
        }
      
      Приложение узнает о том что сервер отменил тревогу по событию: 
      !!! внимание тревога может быть отменена как по инициативе пользователя 
      так и по инициативе оператора пульта охраны. В любом случае приложение
      получит такое сообщение:
        srvCancelAlarm: 
        тело сообщения:
          {
            alarmId: number
          }

      ДЕЙСТВИЕ КОТОРОЕ ОТМЕНЯЕТ ЗАПИСЬ трека // пока пункт в меню "ОТМЕНИТЬ ЗАПИСЬ ТРЕКА"
      Приложение отправляет событие:
        событие: appStopTrack
          {
            token: string,
            payload: { tid: number }
          }

      В ответ ожидает от сервера событие: 
        srvCancelTrack: 
          тело сообщения:
            payload: { tid: number }

      Меню: 
        ----------------------------------------------------------------------
        Учетная запись: 
        можно редактировать все кроме паспорта и фотографии.
        используем сокет. отравляем событие: 
        событие: appUpdateUserProfile
          {
            token: string,
            payload: { user: /* часть объекта User !!![ только поля которые обновились] */ }
          }
        в ответ придет событие: 
        srvUpdateAppUser 
        payload: user //полный объект пользователя. Его нужно сохранить.
        ------------------------------------------------------------------------      
        История вызовов: 
          выводит даты случившихся тревог из массива alarmHistory
        
        Приложение должно слушать событие: 
        По нему нужно обновлять аларм хистори в стейте приложения.
          asvUpdateAlarmHistory
          payload: [alarm1, alarm2 ...]
        -------------------------------------------------------------------------
        Экран помощь. 
        Пассивный баян - нажимаем на пункт - разворачивается ответ. 
        Попозже дам что там должно быть.
        -------------------------------------------------------------------------
        Настройки - один пункт автоматическая подписка. 
          считываем из состояния приложения: autoSubscription
          изменения сохраняем отправляя событие:
          appChangeSubscriptionState:
          {
            token: string,
            payload: { autoSubscription: boolean }
          }
        В обратную ничего не прейдет. Нужно следить что бы такие кнопки не 
        нажимались когда нет соединения с сокетом. 

        ОСТАЛЬНЫЕ ЗДЕСЬ ПУНКТЫ УПРАЗДНИЛИ 
      ------------------------------------------------------------------------      
        Оформить подписку.
        при нажатии на кнопку в модальном окне открывается форма оплаты тинькофф 
        на соответствующую сумму с указанием id пользователя. 
      -----------------------------------------



